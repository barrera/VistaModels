
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file contains the PV class for stream.
//* This is a template file: You may modify this file to implement the 
//* behavior of your component. 
//* 
//* Model Builder version: 3.2.0
//* Generated on: Feb. 24, 2012 05:06:55 PM, (user: mbradley)
//*>

#include "stream_fifo_pv.h"
#include <iostream>

// enable/disable debug output capability
#undef COUT_DBG
#if 1
  #define COUT_DBG(x) if (fifo_debug) cout x
#else
  #define COUT_DBG(...);
#endif
// enable/disable warnings
#undef COUT_WARN
#if 1
  #define COUT_WARN(x) cout x;
#else
  #define COUT_WARN(...);
#endif

using namespace sc_core;
using namespace sc_dt;
using namespace std;

//constructor
stream_fifo_pv::stream_fifo_pv(sc_module_name module_name) 
    : stream_fifo_pv_base(module_name) 
{
    SC_THREAD(pump_out);

    // CallBack to THRead cOUPLEr
    cbTrouple.init(this , din_idx , num_transactions_buffered
                        , &mbv_overflow, &mbv_underflow, &mbv_level
                        , wait_din, latency_din, fifo_debug);

    // initialize control register from user parameters (later overwritten via write to reg_control)
    reg_control = (drop_on_overflow==1) ? DROP_INPACKET : BLOCK_INPACKET;
    reg_status  = OK;
}    


//                   ------------------
bool stream_fifo_pv::din_callback_write(mb_address_type address, unsigned char* data, unsigned size) {
//                   ------------------

    // determine if "alert" port is bound (note cast to name of PVT model)
    sc_interface* alert_iface = dynamic_cast<stream_fifo_pvt*>(this->get_parent())->alert.get_interface(); 


    bool ok2put = cbTrouple.ok2put();
    if (! ok2put) {
        if (reg_control & DROP_INPACKET) 
        {   // config set to drop input packets if no room
            reg_status = DROP_INPACKET;                                           // set status register
            if (alert_iface)                                                      // port may not be bound
                alert_write_dbg((mb_address_type)0x0, (unsigned)DROP_INPACKET);  
            COUT_WARN(<<name()<<" @ "<<sc_time_stamp()<<" WARNING: Dropping input packet write "<<endl);
            return true; 
        } 
        else if (reg_control & BLOCK_INPACKET) 
        {   // config set to block input packets if no room
            reg_status = BLOCK_INPACKET;                                          // set status register
            if (alert_iface)                                                      // port may not be bound
                alert_write_dbg((mb_address_type)0x0, (unsigned)BLOCK_INPACKET);
        }
        else
        {   // do something...
            reg_status = OK;
        }
    }

    COUT_DBG(<<name()<<" @ "<<sc_time_stamp()<<" callback_write, will now put \n");
    cbTrouple.put(address,data,size); // this may block
    return true;
}


//                   --------
void stream_fifo_pv::pump_out() {
//                   --------
    transQuple_t*   transQuple;
    sc_time         makeupTime;

    while (1) 
    {
        // get data from the throuple
        cbTrouple.getAndPop(makeupTime, transQuple);                  // this may block

        // combine makeupTime with latency_process for simulation efficiency
        // makeupTime calculated from bus clock, scale to component clock for T policies
        latency_internalTime = latency_process + makeupTime/clock;    

        COUT_DBG(<<name()<<" @ "<<sc_time_stamp()<<" internalTime= "<< latency_internalTime 
                                             <<" := makeupClock= "<< makeupTime/clock <<" + latency_process= "<< latency_process <<endl);

        // vvvv--- transaction in makeup time + processing time
          mbtp_internalTime0 = (mbtp_internalTime0 + 1) % 3;
          mbtp_internalTime1 = (mbtp_internalTime1 + 1) % 3;
        // ^^^^--- transaction in makeup time + processing time

        // Send data out
        dout_write(transQuple->address, transQuple->data, transQuple->size );  // send out data
        COUT_DBG(<<name()<<" @ "<<sc_time_stamp()<<" output complete \n");
    }

}

//=====================================================================================================
//======================= Not So interesting Below ====================================================
//                   -----------------
bool stream_fifo_pv::din_callback_read(mb_address_type address, unsigned char* data, unsigned size) {
//                   -----------------
    cout <<name()<<" @ "<<sc_time_stamp()<<" WARNING: Unserviced read from port "<<endl;
    return true;
}
// debug and dmi not supported yet...
unsigned stream_fifo_pv::din_callback_read_dbg(mb_address_type address, unsigned char* data, unsigned size) {
    return 0;
}
unsigned stream_fifo_pv::din_callback_write_dbg(mb_address_type address, unsigned char* data, unsigned size) {
    return 0;
}
bool stream_fifo_pv::din_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmiData) {
    return false;
}


bool stream_fifo_pv::config_callback_write(mb_address_type address, unsigned char* data, unsigned size) {
    return true;
}
bool stream_fifo_pv::config_callback_read(mb_address_type address, unsigned char* data, unsigned size) {
    return true;
}
unsigned stream_fifo_pv::config_callback_read_dbg(mb_address_type address, unsigned char* data, unsigned size) {
    return 0;
}
unsigned stream_fifo_pv::config_callback_write_dbg(mb_address_type address, unsigned char* data, unsigned size) {
    return 0;
}
bool stream_fifo_pv::config_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmiData) {
    return false;
}


