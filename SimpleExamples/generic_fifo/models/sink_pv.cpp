
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file contains the PV class for sink.
//* This is a template file: You may modify this file to implement the 
//* behavior of your component. 
//* 
//* Model Builder version: 3.2.0
//* Generated on: Feb. 24, 2012 05:06:56 PM, (user: mbradley)
//* Automatically merged on: Feb. 27, 2012 12:35:58 PM, (user: mbradley)
//* Automatically merged on: Feb. 27, 2012 03:07:14 PM, (user: mbradley)
//* Automatically merged on: Feb. 27, 2012 05:29:30 PM, (user: mbradley)
//*>


#include "sink_pv.h"
#include <iostream>

using namespace sc_core;
using namespace sc_dt;
using namespace std;

//constructor
sink_pv::sink_pv(sc_module_name module_name) 
  : sink_pv_base(module_name) , startCompare(0), err(0)
{
}    

int sink_pv::compare(sc_time t0, mb_address_type a0, unsigned char* d0, unsigned s0
            ,sc_time t1, mb_address_type a1, unsigned char* d1, unsigned s1)
{
#if 0
    int err = 0;

    if (t0 != t1) {
        cout <<name()<<" @ "<<sc_time_stamp()<<" Compare: time stamp mismatch "<< t0 <<" "<< t1 <<endl;
        err++;
    }
    if (a0 != a1) {
        cout <<name()<<" @ "<<sc_time_stamp()<<" Compare: address mismatch "<< a0 <<" "<< a1 <<endl;
        err++;
    }
    if (s0 != s1) {
        cout <<name()<<" @ "<<sc_time_stamp()<<" Compare: size mismatch "<< s0 <<" "<< s1 <<endl;
        err++;
    }
    unsigned minS = (s0<s1) ? s0:s1;
    for (unsigned i=0; i<minS; i++)
    {
        if (d0[i] != d1[i]) {
            cout <<name()<<" @ "<<sc_time_stamp()<<" Compare: data mismatch "<< i <<" "<< d0[i] <<" "<< d1[i] <<endl;
            err++;
        }
    }

    return err;
#else
    return 0;
#endif
}

// destructor
sink_pv::~sink_pv()
{

#if 0
    if (err)
        cout <<name()<<" test FAILED "<< err <<endl;
    else
        cout <<name()<<" test PASSED "<< err <<endl;
#endif
}

// Read callback for s0 port.
// Returns true when successful.
bool sink_pv::s0_callback_read(mb_address_type address, unsigned char* data, unsigned size) {
  
  return true;
}


// Read callback for s1 port.
// Returns true when successful.
bool sink_pv::s1_callback_read(mb_address_type address, unsigned char* data, unsigned size) {
  
  return true;
}


// Write callback for s0 port.
// Returns true when successful.
bool sink_pv::s0_callback_write(mb_address_type address, unsigned char* data, unsigned size) {

#if 0
    if (startCompare == 0x11)
    {
        err += compare(sc_time_stamp(), address, data, size, storeTrans.arriveTime, storeTrans.address, storeTrans.data, storeTrans.size);
        startCompare = 0;
    }
    else if (startCompare == 0x10)
    {
        storeTrans.allocate(size);
        storeTrans.copyIn(sc_time_stamp(), address, data);
        startCompare = 1;
    }
    else
    {
        cout <<name()<<" @ "<<sc_time_stamp()<<" Sequence compare ERROR startCompare= "<< startCompare <<endl;
        err++;
    }
#endif 
  return true;
}


// Write callback for s1 port.
// Returns true when successful.
bool sink_pv::s1_callback_write(mb_address_type address, unsigned char* data, unsigned size) {
 
#if 0
    if (startCompare == 1)
    {
        err += compare( storeTrans.arriveTime, storeTrans.address, storeTrans.data, storeTrans.size, sc_time_stamp(), address, data, size);
        startCompare = 0x10;
    }
    else if (startCompare == 0)
    {
        storeTrans.allocate(size);
        storeTrans.copyIn(sc_time_stamp(), address, data);
        startCompare = 0x11;
    }
    else
    {
        cout <<name()<<" @ "<<sc_time_stamp()<<" Sequence compare ERROR startCompare= "<< startCompare <<endl;
        err++;
    }
#endif 
  return true;
}


unsigned sink_pv::s0_callback_read_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
}

unsigned sink_pv::s0_callback_write_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
}

bool sink_pv::s0_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmiData) {
  return false;
}



unsigned sink_pv::s1_callback_read_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
}

unsigned sink_pv::s1_callback_write_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
}

bool sink_pv::s1_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmiData) {
  return false;
}


