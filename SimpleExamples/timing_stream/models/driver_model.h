
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected. 
//* DO NOT MODIFY THIS FILE.
//*
//* This file is generated according to the parameters in the 
//* Model Builder form.
//* This class contains the infrastructure to define the behavior of the component.
//* The driver_pv will be derived from this class.
//*
//* Model Builder version: 3.2.0
//* Generated on: Feb. 29, 2012 03:31:59 AM, (user: jon)
//*>


#pragma once

#include "model_builder.h"
#ifdef MODEL_BUILDER_VERSION_NUMBER
#if 320 != MODEL_BUILDER_VERSION_NUMBER
#error "This model was generated using Model Builder 3.2.0. Please regenerate model."
#endif
#else
#error "Please regenerate model."
#endif




#include "generic_protocol.h"

using namespace ::tlm;

class driver_pv_base;
class driver_pv_base_mb_compatibility : public mb::mb_module {
  friend class driver_pv_base;
 public:
  typedef unsigned int mb_address_type;
 protected:
  driver_pv_base_mb_compatibility(sc_core::sc_module_name& module_name)
    : mb::mb_module(module_name) {}
 
};

class driver_pv_base : public driver_pv_base_mb_compatibility {
 private:
  typedef driver_pv_base_mb_compatibility mb_compatibility_class;
 public:
  typedef esl::tlm_types::Address mb_address_type;
 public:
  typedef driver_pv_base self;
  SC_HAS_PROCESS(driver_pv_base);
  driver_pv_base(sc_core::sc_module_name& module_name);
  void print_parameters();
  
  enum port_enum {y_idx };
  
 private:

  mb::tlm20::bw_process<tlm::tlm_base_protocol_types> m_y_bw_process;

 protected:


  virtual void y_invalidate_direct_mem_ptr_callback(sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
  }

  

  

  

 protected:

  ////////////////////////////////////////
  // functions for initiator port: y
  ////////////////////////////////////////
  bool y_transport(tlm::tlm_base_protocol_types::tlm_payload_type& trans) {
    sc_core::sc_time t;
    trans.set_response_status(tlm::TLM_INCOMPLETE_RESPONSE);
    y->b_transport(trans, t);
    return trans.get_response_status() == tlm::TLM_OK_RESPONSE;
  }


  bool y_read(mb_address_type address, unsigned char* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);
    
    bool retv = mb::tlm20::do_b_transport(*y[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));
    trans->release();
    return retv;

  }
  bool y_read(mb_address_type address, unsigned short* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);
    
    bool retv = mb::tlm20::do_b_transport(*y[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));
    trans->release();
    return retv;

  }
  bool y_read(mb_address_type address, unsigned int* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);
    
    bool retv = mb::tlm20::do_b_transport(*y[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));
    trans->release();
    return retv;

  }
  bool y_read(mb_address_type address, sc_dt::uint64* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);
    
    bool retv = mb::tlm20::do_b_transport(*y[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));
    trans->release();
    return retv;

  }
  bool y_read(mb_address_type address, char* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);
    
    bool retv = mb::tlm20::do_b_transport(*y[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));
    trans->release();
    return retv;

  }
  bool y_read(mb_address_type address, short* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);
    
    bool retv = mb::tlm20::do_b_transport(*y[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));
    trans->release();
    return retv;

  }
  bool y_read(mb_address_type address, int* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);
    
    bool retv = mb::tlm20::do_b_transport(*y[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));
    trans->release();
    return retv;

  }
  bool y_read(mb_address_type address, sc_dt::int64* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);
    
    bool retv = mb::tlm20::do_b_transport(*y[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));
    trans->release();
    return retv;

  }
  
  bool y_write(mb_address_type address,unsigned char* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);
    
    bool retv = mb::tlm20::do_b_transport(*y[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));
    trans->release();
    return retv;

  }
  
  bool y_write(mb_address_type address,unsigned short* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);
    
    bool retv = mb::tlm20::do_b_transport(*y[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));
    trans->release();
    return retv;

  }
  
  bool y_write(mb_address_type address,unsigned int* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);
    
    bool retv = mb::tlm20::do_b_transport(*y[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));
    trans->release();
    return retv;

  }
  
  bool y_write(mb_address_type address,sc_dt::uint64* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);
    
    bool retv = mb::tlm20::do_b_transport(*y[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));
    trans->release();
    return retv;

  }
  
  bool y_write(mb_address_type address,char* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);
    
    bool retv = mb::tlm20::do_b_transport(*y[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));
    trans->release();
    return retv;

  }
  
  bool y_write(mb_address_type address,short* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);
    
    bool retv = mb::tlm20::do_b_transport(*y[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));
    trans->release();
    return retv;

  }
  
  bool y_write(mb_address_type address,int* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);
    
    bool retv = mb::tlm20::do_b_transport(*y[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));
    trans->release();
    return retv;

  }
  
  bool y_write(mb_address_type address,sc_dt::int64* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);
    
    bool retv = mb::tlm20::do_b_transport(*y[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));
    trans->release();
    return retv;

  }

  bool y_read(mb_address_type address,unsigned char& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(0);
    
    bool retv = mb::tlm20::do_b_transport(*y[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));
    trans->release();
    return retv;

  }

  bool y_read(mb_address_type address,unsigned short& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(0);
    
    bool retv = mb::tlm20::do_b_transport(*y[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));
    trans->release();
    return retv;

  }

  bool y_read(mb_address_type address,unsigned int& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(0);
    
    bool retv = mb::tlm20::do_b_transport(*y[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));
    trans->release();
    return retv;

  }

  bool y_read(mb_address_type address,sc_dt::uint64& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(0);
    
    bool retv = mb::tlm20::do_b_transport(*y[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));
    trans->release();
    return retv;

  }

  bool y_read(mb_address_type address,char& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(0);
    
    bool retv = mb::tlm20::do_b_transport(*y[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));
    trans->release();
    return retv;

  }

  bool y_read(mb_address_type address,short& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(0);
    
    bool retv = mb::tlm20::do_b_transport(*y[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));
    trans->release();
    return retv;

  }

  bool y_read(mb_address_type address,int& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(0);
    
    bool retv = mb::tlm20::do_b_transport(*y[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));
    trans->release();
    return retv;

  }

  bool y_read(mb_address_type address,sc_dt::int64& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(0);
    
    bool retv = mb::tlm20::do_b_transport(*y[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));
    trans->release();
    return retv;

  }
  
  bool y_write(mb_address_type address,unsigned char data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(0);
    
    bool retv = mb::tlm20::do_b_transport(*y[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));
    trans->release();
    return retv;

  }
  
  bool y_write(mb_address_type address,unsigned short data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(0);
    
    bool retv = mb::tlm20::do_b_transport(*y[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));
    trans->release();
    return retv;

  }
  
  bool y_write(mb_address_type address,unsigned int data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(0);
    
    bool retv = mb::tlm20::do_b_transport(*y[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));
    trans->release();
    return retv;

  }
  
  bool y_write(mb_address_type address,sc_dt::uint64 data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(0);
    
    bool retv = mb::tlm20::do_b_transport(*y[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));
    trans->release();
    return retv;

  }
  
  bool y_write(mb_address_type address,char data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(0);
    
    bool retv = mb::tlm20::do_b_transport(*y[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));
    trans->release();
    return retv;

  }
  
  bool y_write(mb_address_type address,short data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(0);
    
    bool retv = mb::tlm20::do_b_transport(*y[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));
    trans->release();
    return retv;

  }
  
  bool y_write(mb_address_type address,int data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(0);
    
    bool retv = mb::tlm20::do_b_transport(*y[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));
    trans->release();
    return retv;

  }
  
  bool y_write(mb_address_type address,sc_dt::int64 data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(0);
    
    bool retv = mb::tlm20::do_b_transport(*y[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));
    trans->release();
    return retv;

  }



  ///////////////////////////////////////
  // dbg functions for port: y
  /////////////////////////////////////// 

  unsigned y_read_dbg(mb_address_type address, unsigned char* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*y[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));
    trans->release();
    return retv;
  }
  unsigned y_read_dbg(mb_address_type address, unsigned short* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*y[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));
    trans->release();
    return retv;
  }
  unsigned y_read_dbg(mb_address_type address, unsigned int* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*y[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));
    trans->release();
    return retv;
  }
  unsigned y_read_dbg(mb_address_type address, sc_dt::uint64* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*y[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));
    trans->release();
    return retv;
  }
  unsigned y_read_dbg(mb_address_type address, char* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*y[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));
    trans->release();
    return retv;
  }
  unsigned y_read_dbg(mb_address_type address, short* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*y[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));
    trans->release();
    return retv;
  }
  unsigned y_read_dbg(mb_address_type address, int* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*y[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));
    trans->release();
    return retv;
  }
  unsigned y_read_dbg(mb_address_type address, sc_dt::int64* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*y[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));
    trans->release();
    return retv;
  }

  unsigned y_write_dbg(mb_address_type address, unsigned char* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*y[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));
    
    trans->release();
    return retv;
  }

  unsigned y_write_dbg(mb_address_type address, unsigned short* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*y[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));
    
    trans->release();
    return retv;
  }

  unsigned y_write_dbg(mb_address_type address, unsigned int* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*y[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));
    
    trans->release();
    return retv;
  }

  unsigned y_write_dbg(mb_address_type address, sc_dt::uint64* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*y[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));
    
    trans->release();
    return retv;
  }

  unsigned y_write_dbg(mb_address_type address, char* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*y[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));
    
    trans->release();
    return retv;
  }

  unsigned y_write_dbg(mb_address_type address, short* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*y[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));
    
    trans->release();
    return retv;
  }

  unsigned y_write_dbg(mb_address_type address, int* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*y[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));
    
    trans->release();
    return retv;
  }

  unsigned y_write_dbg(mb_address_type address, sc_dt::int64* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*y[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));
    
    trans->release();
    return retv;
  }
  
  unsigned y_read_dbg(mb_address_type address, unsigned char& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*y[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));
    trans->release();
    return retv;
  }
  
  unsigned y_read_dbg(mb_address_type address, unsigned short& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*y[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));
    trans->release();
    return retv;
  }
  
  unsigned y_read_dbg(mb_address_type address, unsigned int& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*y[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));
    trans->release();
    return retv;
  }
  
  unsigned y_read_dbg(mb_address_type address, sc_dt::uint64& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*y[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));
    trans->release();
    return retv;
  }
  
  unsigned y_read_dbg(mb_address_type address, char& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*y[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));
    trans->release();
    return retv;
  }
  
  unsigned y_read_dbg(mb_address_type address, short& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*y[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));
    trans->release();
    return retv;
  }
  
  unsigned y_read_dbg(mb_address_type address, int& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*y[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));
    trans->release();
    return retv;
  }
  
  unsigned y_read_dbg(mb_address_type address, sc_dt::int64& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*y[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));
    trans->release();
    return retv;
  }

  unsigned y_write_dbg(mb_address_type address, unsigned char data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*y[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));
    trans->release();
    return retv;
  }

  unsigned y_write_dbg(mb_address_type address, unsigned short data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*y[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));
    trans->release();
    return retv;
  }

  unsigned y_write_dbg(mb_address_type address, unsigned int data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*y[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));
    trans->release();
    return retv;
  }

  unsigned y_write_dbg(mb_address_type address, sc_dt::uint64 data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*y[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));
    trans->release();
    return retv;
  }

  unsigned y_write_dbg(mb_address_type address, char data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*y[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));
    trans->release();
    return retv;
  }

  unsigned y_write_dbg(mb_address_type address, short data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*y[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));
    trans->release();
    return retv;
  }

  unsigned y_write_dbg(mb_address_type address, int data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*y[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));
    trans->release();
    return retv;
  }

  unsigned y_write_dbg(mb_address_type address, sc_dt::int64 data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*y[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));
    trans->release();
    return retv;
  }


  tlm::tlm_generic_payload* payload_on_stack;

  ////////////////////////////////////////
  // request DMI for port: y
  ////////////////////////////////////////
  bool y_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmi_data) {
    tlm::tlm_generic_payload* trans = payload_on_stack;
    if (!payload_on_stack)
      trans = mb::tlm20::get_object_pull().new_payload();

    bool retv = false;

    {
      mb::tlm20::save_payload<tlm::tlm_generic_payload> save(*trans);
      trans->set_command(tlm::TLM_READ_COMMAND);
      trans->set_address(address);
      retv = y->get_direct_mem_ptr(*trans, dmi_data);
    }
    if (!payload_on_stack)
      trans->release();
    return retv;
  }

  bool y_get_direct_memory_ptr(tlm::tlm_command command, mb_address_type address, tlm::tlm_dmi& dmi_data) {
    tlm::tlm_generic_payload* trans = payload_on_stack;
    if (!payload_on_stack)
      trans = mb::tlm20::get_object_pull().new_payload();

    trans->set_command(command);
    trans->set_address(address);
    
    bool retv = y->get_direct_mem_ptr(*trans, dmi_data);
    if (!payload_on_stack)
      trans->release();
    return retv;
  }

 

   
  
  
 

 public:
  typedef tlm::tlm_base_protocol_types y_protocol_types;
  typedef tlm::tlm_base_protocol_types::tlm_payload_type y_payload_type;

 public:
  // port declarations 

  tlm::tlm_initiator_socket <32, tlm::tlm_base_protocol_types> y;  

    
 public:

  void send_b_transport(unsigned port_index, tlm::tlm_generic_payload& trans, sc_core::sc_time& t) {
    if (port_index > get_port_count() || !is_master(port_index))
      return;
    switch (port_index) {
    case y_idx:
      y->b_transport(trans, t);
    }
  }

  unsigned send_transport_dbg(unsigned port_index, tlm::tlm_generic_payload& trans) {
    if (port_index > get_port_count() || !is_master(port_index))
      return 0;
    switch (port_index) {
    case y_idx:
      return y->transport_dbg(trans);
    }
    return 0;
  }
  
 protected:
  sc_core::sc_time clock;
  sc_core::sc_time generic_clock;
  double nominal_voltage;
  bool mb_debug;
  bool verbose_parameters;
  const char* DriverFunction;
  const char* AddrDist;
  const char* SizeDist;
  const char* WaitDist;
  unsigned int NumberPackets;
  unsigned int MaxPacketSize;

  

 protected:
};



/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected.
//* DO NOT MODIFY THIS FILE.
//*
//* This file is used only for learning the component.
//* It contains the machine architecture class for your driver model.
//* 
//* Model Builder version: 3.2.0
//* Generated on: Feb. 29, 2012 03:31:59 AM, (user: jon)
//*>


#pragma once

#include "model_builder.h"


class driver_machine_arch : public MachineArch { 
    
    public:
    
    public:
        
        ////////////////////////////////////////////////////////////////////
        //   function for port: y
        ////////////////////////////////////////////////////////////////////
        
        //////
        // functions for port: y, transaction: READ
        //////
        
        void transaction_instance__y__READ
          (
            sc_dt::uint64 address,
            sc_dt::uint64 size,
            sc_dt::uint64 data, 
            bool has_been_error, 
            sc_dt::uint64 currentTime
          );
        
        //////
        // functions for port: y, transaction: WRITE
        //////
        
        void transaction_instance__y__WRITE
          (
            sc_dt::uint64 address,
            sc_dt::uint64 size,
            sc_dt::uint64 data, 
            bool has_been_error, 
            sc_dt::uint64 currentTime
          );
        
        
    
    public:
        void configureClock(unsigned portIndex, sc_dt::uint64 clock) {
          m_clocks[portIndex] = clock;
        }
        void startTransaction(unsigned portIndex, unsigned transactionIndex, sc_dt::uint64 currentTime);
        VariableBase* getVariableBasePtrByName(const char* name);
        Register* getRegisterByName(const char* name);
        virtual void reset();
        
        virtual bool getAddressRange(unsigned portIndex, sc_dt::uint64& begin, sc_dt::uint64& end);
        
    
    public:
        void callTransaction(unsigned portIndex, unsigned transactionIndex, sc_dt::uint64 address, sc_dt::uint64 size, sc_dt::uint64 data, bool has_been_error, sc_dt::uint64 currentTime);
    
    public:
        //constructor
        driver_machine_arch();
    
};

/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected. 
//* DO NOT MODIFY THIS FILE.
//*
//* This file is generated according to the parameters in the 
//* Model Builder form.
//* 
//* Any change in parameters, policies, ports, protocols, etc. will change this file
//* upon generation of the timing model (using generate_timing_model command).
//* The driver_t will be derived from this class.
//*
//* Model Builder version: 3.2.0
//* Generated on: Feb. 29, 2012 03:31:59 AM, (user: jon)
//*>


#pragma once

#include "model_builder.h"
#include "generic_protocol.h"
 


class driver_t_base : public papoulis::SystemCBaseModel {
public:
  static driver_t_base* create_t(const char* _name, long simulation);
public:
  driver_t_base(sc_core::sc_module_name& module_name, long simulation);
 
  enum port_enum {y};

protected:
  // The following callbacks are called whenever there is a transaction start or end in the port
  // If you want to add your own code (like updating the machine architecture object), 
  // you have to overload these functions in your derived class.

  virtual void accept_generic_READ
    (long port_index,
     sc_dt::int64 time,
     long& burst_size,
     sc_dt::uint64 ADDR,
     sc_dt::uint64 rDATA,
     sc_dt::uint64& PRIORITY,
     sc_dt::uint64& BURST,
     sc_dt::uint64 SIZE,
     sc_dt::uint64& STATUS) {};
  virtual void end_generic_READ
    (long port_index,
     sc_dt::uint64 time,
     long& burst_size,
     sc_dt::uint64 ADDR,
     sc_dt::uint64 rDATA,
     sc_dt::uint64& PRIORITY,
     sc_dt::uint64& BURST,
     sc_dt::uint64 SIZE,
     sc_dt::uint64& STATUS) {};

  virtual void accept_generic_WRITE
    (long port_index,
     sc_dt::int64 time,
     long& burst_size,
     sc_dt::uint64 ADDR,
     sc_dt::uint64 wDATA,
     sc_dt::uint64& PRIORITY,
     sc_dt::uint64& BURST,
     sc_dt::uint64 SIZE,
     sc_dt::uint64& STATUS) {};
  virtual void end_generic_WRITE
    (long port_index,
     sc_dt::uint64 time,
     long& burst_size,
     sc_dt::uint64 ADDR,
     sc_dt::uint64 wDATA,
     sc_dt::uint64& PRIORITY,
     sc_dt::uint64& BURST,
     sc_dt::uint64 SIZE,
     sc_dt::uint64& STATUS) {};


public:
  virtual driver_machine_arch* getMachineArch() const {
    return m_machineArch;
  }

  virtual bool portHasRegisters(unsigned portIndex);
  
  virtual bool triggerRegistersGotHit(unsigned portIndex, tlm::tlm_generic_payload& trans);

protected:
  /* schedule functions */
  void schedule_generic_READ
    (long port_index,
     sc_dt::uint64 delay,
     long& burst_size,
     esl::include::transaction_power& power , long ADDR, long* rDATA, long PRIORITY, long BURST, long SIZE, long STATUS);
  void schedule_generic_WRITE
    (long port_index,
     sc_dt::uint64 delay,
     long& burst_size,
     esl::include::transaction_power& power , long ADDR, long* wDATA, long PRIORITY, long BURST, long SIZE, long STATUS);
  
protected:
  /* machine architecture */
  driver_machine_arch* m_machineArch;

protected:
  friend class driver_model;
  
  

protected:
  // parameters
  sc_core::sc_time clock;
  sc_core::sc_time generic_clock;
  double nominal_voltage;
  bool mb_debug;
  bool verbose_parameters;
  const char* DriverFunction;
  const char* AddrDist;
  const char* SizeDist;
  const char* WaitDist;
  unsigned int NumberPackets;
  unsigned int MaxPacketSize;

protected:
  long m_simulation;

 
  

  static const unsigned port_count = 1;
  papoulis::SystemCBaseModel::PortDescription port_descriptions[port_count];
  
  

protected:
  std::vector<esl::sc_sim::pipeline_policy*> m_pipeline_vector;
  std::vector<esl::sc_sim::sequential_policy*> m_sequential_vector;
  std::vector<esl::sc_sim::delay_policy*> m_delay_vector;
  std::vector<esl::sc_sim::uniform_bus_policy*> m_bus_vector;
  std::vector<esl::sc_sim::power_policy*> m_power_vector;
  std::vector<esl::sc_sim::state_power_policy*> m_state_power_vector;
public:
  virtual void update_sync_all();
  virtual void update_pipeline_parameters(esl::sc_sim::pipeline_policy* handle);
  virtual void update_sequential_parameters(esl::sc_sim::sequential_policy* handle);
  virtual void update_delay_parameters(esl::sc_sim::delay_policy* handle);
  virtual void update_bus_parameters(esl::sc_sim::uniform_bus_policy* handle);
  virtual void update_power_parameters(esl::sc_sim::power_policy* handle);
  virtual void update_state_power_parameters(esl::sc_sim::state_power_policy* handle);
protected: /* InterfaceFunctions */
  virtual TransactionCallbackFunctionPointer getTransactionCallback(unsigned callbackIndex);
  config::real80 get_state_power();
protected:

  void start_transaction_generic_READ
    (esl::include::TRequest* request,
     unsigned port_index,
     sc_dt::uint64 startTime,
     sc_dt::uint64 endTime,
     sc_dt::uint64* parameters,
     bool hasBeenError);
  void end_transaction_generic_READ
    (esl::include::TRequest* request,
     unsigned port_index,
     sc_dt::uint64 startTime,
     sc_dt::uint64 endTime,
     sc_dt::uint64* parameters,
     bool hasBeenError);
  void start_transaction_generic_WRITE
    (esl::include::TRequest* request,
     unsigned port_index,
     sc_dt::uint64 startTime,
     sc_dt::uint64 endTime,
     sc_dt::uint64* parameters,
     bool hasBeenError);
  void end_transaction_generic_WRITE
    (esl::include::TRequest* request,
     unsigned port_index,
     sc_dt::uint64 startTime,
     sc_dt::uint64 endTime,
     sc_dt::uint64* parameters,
     bool hasBeenError);
};

/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected.
//* DO NOT MODIFY THIS FILE.
//*
//* This file contains the PVT class for driver.
//* It connects between the PV and T models.
//* Your top-level design should instantiate this model.
//* 
//* In order to synchronize the activty between the PV and the T models, every 
//* PV transaction is monitored and queued in the T sync ports.
//* Whenever a synchronization point is reached, the T models are executed and 
//* the corresponding T transactions are launched.
//* A synchronization point is reached whenever there is a wait statement on a testbench thread. 
//*
//* Model Builder version: 3.2.0
//* Generated on: Feb. 29, 2012 03:31:59 AM, (user: jon)
//*>

#pragma once

#include "model_builder.h"



 


// forward declaration for pv class
class driver_pv;



class driver_pvt_param_defaults {
  
public:
  driver_pvt_param_defaults(const char* hier_name) {

    sc_core::sc_time clock;
    sc_core::sc_time generic_clock;
    double nominal_voltage;
    bool mb_debug;
    bool verbose_parameters;
    const char* DriverFunction;
    const char* AddrDist;
    const char* SizeDist;
    const char* WaitDist;
    unsigned int NumberPackets;
    unsigned int MaxPacketSize;
    clock = ::mb::sysc::sdInitParameter<sc_core::sc_time>("clock", sc_core::sc_time(10, sc_core::SC_NS), hier_name);
    generic_clock = ::mb::sysc::sdInitParameter<sc_core::sc_time>("generic_clock", clock, hier_name);
    nominal_voltage = ::mb::sysc::sdInitParameter<double>("nominal_voltage", 1, hier_name);
    mb_debug = ::mb::sysc::sdInitParameter<bool>("mb_debug", false, hier_name);
    verbose_parameters = ::mb::sysc::sdInitParameter<bool>("verbose_parameters", true, hier_name);
    DriverFunction = ::mb::sysc::sdInitParameter<const char*>("DriverFunction", "simple", hier_name);
    AddrDist = ::mb::sysc::sdInitParameter<const char*>("AddrDist", "constant 0", hier_name);
    SizeDist = ::mb::sysc::sdInitParameter<const char*>("SizeDist", "constant 1", hier_name);
    WaitDist = ::mb::sysc::sdInitParameter<const char*>("WaitDist", "constant 1", hier_name);
    NumberPackets = ::mb::sysc::sdInitParameter<unsigned int>("NumberPackets", 10, hier_name);
    MaxPacketSize = ::mb::sysc::sdInitParameter<unsigned int>("MaxPacketSize", 100, hier_name);
    ::mb::sysc::sdPropagateParameters();
  }
};

class driver_pvt : public esl::sc_sim::PVTBaseModel, 
                          public mb::utl::cb_owner, 
                          private driver_pvt_param_defaults {

 public:
  typedef driver_pvt self_type;

 public: 
  // Constructor
  driver_pvt(sc_core::sc_module_name module_name); 
  ~driver_pvt(); 

 public:
    //access the T instance
  inline driver_t_base* getT() const {
    return m_driver_t;
  }
  
  //access the PV instance
  inline driver_pv* getPV() const {
    return m_driver_pv;
  }

  virtual SystemCBaseModel* getSystemCBaseModel() const {
    return getT();
  }

 private:
  void bind();
  

  void b_transport_outside_y(tlm::tlm_generic_payload& p, sc_core::sc_time& t);

 private:
  //T instance
  driver_t_base* m_driver_t;
  
  //PV instance
  driver_pv* m_driver_pv;

 public:
  // External ports

  typedef esl::sc_sim::pvt_initiator_socket<32, tlm::tlm_base_protocol_types, 1, sc_core::SC_ONE_OR_MORE_BOUND> y_type;
  y_type y;

 private:
  // PV connection ports

  typedef mb::tlm20::target_socket_cb<32> y_entry_type;
  y_entry_type y_entry;     

 public:
  sc_core::sc_time y_time;


 private:

  struct y_nb_connector : public tlm::tlm_fw_nonblocking_transport_if<>, public ::mb::tlm20::socket_tracer_holder {
    driver_pvt& m_owner;
    y_nb_connector(driver_pvt& owner) : m_owner(owner) {
    }
    virtual tlm::tlm_sync_enum nb_transport_fw(tlm::tlm_generic_payload& trans, 
                                               tlm::tlm_phase& phase, 
                                               sc_core::sc_time& t) {
      return m_owner.y.nb_transport_fw((tlm::tlm_base_protocol_types::tlm_payload_type&)trans, phase, t);
    }
    virtual ::mb::tlm20::socket_tracer *get_socket_tracer() {
      return &m_owner.y;
    }
  };
  friend struct y_nb_connector;
  y_nb_connector m_y_nb_connector;





  tlm::tlm_sync_enum receive_nb_transport_y(tlm::tlm_generic_payload& trans,
                                                       tlm::tlm_phase& phase,
                                                       sc_core::sc_time& t) {
    return getT()->receive_nb_transport(0, trans, phase, t);
  }

};


