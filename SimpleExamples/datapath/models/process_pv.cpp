/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file contains the PV class for process.
//* This is a template file: You may modify this file to implement the
//* behavior of your component.
//*
//* Model Builder version: 3.2.0RC
//* Generated on: Feb. 23, 2012 08:28:55 AM, (user: jon)
//*>


#include "process_pv.h"
#include <iostream>

using namespace sc_core;
using namespace sc_dt;
using namespace std;

//constructor
process_pv::process_pv(sc_module_name module_name)
    : process_pv_base(module_name)
{
    SC_THREAD(thread);
    // Initialize the size of the transaction queue
    fifo.nb_bound(InputFifoDepth+PipelineStages);
    // Initialize the entries in the queue of process finish times.
    for (unsigned int i = 0; i < PipelineStages; i++) pipeInTimeQ.push(SC_ZERO_TIME);
}

void process_pv::thread()
{
    datastruct *ds;
    int proc;
    sc_time startProcT;

    for(;;) {
        // Get the next transaction to be processed.  Do not remove it from the queue
        ds = fifo.peek();

        // Calculate the time that we could start processing the transaction, which is the
        // later of the time we received the input or the time the last element finished processing
        startProcT = pipeInTimeQ.front();
        pipeInTimeQ.pop();
        startProcT = (startProcT > ds->startT) ? startProcT : ds->startT;

        // Calculate the time to wait until we can start processing.  This can not be less than 0
        proc = (startProcT/clock) - (sc_time_stamp()/clock);
        if(proc < -ProcessDelay) {
            proc = -ProcessDelay;
        }
        ProcessDelta = ProcessDelay + proc;

        // cout << sc_simulation_time() << ": processDelta = " << processDelta << endl;

        // Timing policy: Sequential delay TP2.write -> TP1.write of ProcessDelta cycles
        TP1 = (TP1 + 1) % 8;
        TP2 = (TP2 + 1) % 8;

        // Save the current token information for the upcoming transaction and clear it from the queue
        set_current_token(ds->currentToken);
        fifo.get();
        // Save the time that we finished processing this transaction
        pipeInTimeQ.push(sc_time_stamp());

        master_1_write(ds->address, ds->data, ds->size);

        free(ds->data);
        free(ds);
    }
}

// Write callback for slave port.
// Returns true when successful.
bool process_pv::slave_1_callback_write(mb_address_type address, unsigned char* data, unsigned size)
{
    // Save the transaction information in a local datastructure
    datastruct* ds = new datastruct;
    ds->address = address;
    ds->data = new unsigned char [size];
    memcpy(ds->data, data, size);
    ds->size = size;
    ds->currentToken = get_current_token();

    // Calculate the cycles until the input transaction will be complete
    int throughput = size / getSystemCBaseModel()->get_port_width(slave_1_idx);
    int receiveT = throughput + InputDelay;
    InputDelta = receiveT;

    bool putBlocked = !fifo.nb_can_put();
    fifo.put(ds);

    ds->startT = sc_time_stamp() + (receiveT * clock);

    if (putBlocked) {
        // Timing policy: Sequential delay TP4.write -> TP3.write of inputDelta cycles
        TP3 = (TP3 + 1) % 8;
        TP4 = (TP4 + 1) % 8;
    }

    return true;
}
