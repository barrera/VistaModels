/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file contains the PV class for process.
//* This is a template file: You may modify this file to implement the
//* behavior of your component.
//*
//* Model Builder version: 3.2.0RC
//* Generated on: Feb. 23, 2012 08:28:55 AM, (user: jon)
//*>


#include "process_pv.h"
#include <iostream>

#include <vector>

using namespace sc_core;
using namespace sc_dt;
using namespace std;

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//constructor

process_pv::process_pv(sc_module_name module_name)
    : process_pv_base(module_name)
{
    SC_THREAD(pipeline_thread);
    SC_THREAD(process_thread);

    SC_THREAD(master_1_thread);
    SC_THREAD(master_2_thread);
    SC_THREAD(master_3_thread);
    SC_THREAD(master_4_thread);
    SC_THREAD(master_5_thread);
    SC_THREAD(master_6_thread);
    SC_THREAD(master_7_thread);
    SC_THREAD(master_8_thread);


    for (unsigned int i = 0; i < NumberOfPorts; i++) {
        slave_fifo[i].nb_bound(InputFifoDepth);
        master_fifo[i].nb_bound(1);
    }

    pipeline.nb_bound(PipelineStages);

    for (unsigned int j = 0; j < PipelineStages; j++) pipeInTime.push(SC_ZERO_TIME);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

bool datastructSortOnTime(const datastruct* d1, const datastruct* d2)
{
    return d1->receiveT < d2->receiveT;
}

void process_pv::pipeline_thread()
{
    datastruct *ds;
    vector<datastruct *> v;
    for(;;) {
        while ( 1 ) {
            v.clear();
            for (int i = 0; i < NumberOfPorts; i++) {
                ds = NULL;
                if(slave_fifo[i].nb_peek(ds)) {
                    if(ds) {
                        v.push_back(ds);
                    }
                }
            }
            if(v.size()) {
                break;
            } else {
                wait (slave_fifo[0].ok_to_get() |
                      slave_fifo[1].ok_to_get() |
                      slave_fifo[2].ok_to_get() |
                      slave_fifo[3].ok_to_get() |
                      slave_fifo[4].ok_to_get() |
                      slave_fifo[5].ok_to_get() |
                      slave_fifo[6].ok_to_get() |
                      slave_fifo[7].ok_to_get());
            }
        }

        // This sorts the data in the order of recieve time
        sort(v.begin(), v.end(), datastructSortOnTime);

        bool put_some = false;
        for (vector<datastruct *>::iterator it = v.begin(); it != v.end(); it++) {
            int p(((*it)->path) - 1);
            // Only put the item onto the processing pipeline if the output fifo is ready to recieve
            if(master_fifo[p].nb_can_put()) {
                pipeline.put(slave_fifo[p].get());
                put_some = true;
            }
        }
        if(!put_some) {
            wait (master_fifo[0].ok_to_put() |
                  master_fifo[1].ok_to_put() |
                  master_fifo[2].ok_to_put() |
                  master_fifo[3].ok_to_put() |
                  master_fifo[4].ok_to_put() |
                  master_fifo[5].ok_to_put() |
                  master_fifo[6].ok_to_put() |
                  master_fifo[7].ok_to_put());
        }
    }
}

void process_pv::process_thread()
{
    datastruct *ds;
    int proc;
    sc_time startProcT;

    for(;;) {
        // Get the next transaction to be processed.  Do not remove it from the queue
        ds = pipeline.peek();

        // Calculate the time that we could start processing the transaction, which is the
        // later of the time we received the input or the time the last element finished processing
        startProcT = pipeInTime.front();
        pipeInTime.pop();
        startProcT = (startProcT > ds->startT) ? startProcT : ds->startT;

        // Calculate the time to wait until we can start processing.  This can not be less than 0
        proc = (startProcT/clock) - (sc_time_stamp()/clock);


        if(proc < -ProcessDelay) {
            proc = -ProcessDelay;
        }
        ProcessDelta = ProcessDelay + proc;

        // Timing policy: Sequential delay ProcessDelay_start.write -> ProcessDelay_stop.write of ProcessDelta cycles
        ProcessDelay_start = (ProcessDelay_start + 1) % 8;
        ProcessDelay_stop = (ProcessDelay_stop + 1) % 8;

        // get the data from the pipeline
        pipeline.get();

        // process the data
        int *d = (int *) ds->data;
        d[0] = d[0]+100;

        // Save the time that we finished processing this transaction - should this be done after the write????
        pipeInTime.push(sc_time_stamp());

        // Send the data out on the correct master fifo - this shouldn't block as we previously checked that we should
        // not process an item unless its output path is free to go...
        master_fifo[ds->path - 1].put(ds);
    }
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void process_pv::general_master_thread(int path,
                                       bool (process_pv_base::*writeMethod)(mb_address_type, unsigned char *, unsigned, unsigned))
{
    datastruct *ds;
    for(;;) {
        ds = master_fifo[path-1].peek();
        set_current_token(ds->currentToken);
        int *d = (int *) ds->data;
        cout << sc_simulation_time() << ":" << name() << " [" << path << "] sending data = " << d[0] << endl;
        (this->*writeMethod)(ds->address, ds->data, ds->size, 0);
        master_fifo[path-1].get();
        free(ds->data);
        free(ds);
    }
}

void process_pv::master_1_thread()
{
    general_master_thread(1, &process_pv_base::master_1_write);
}

void process_pv::master_2_thread()
{
    general_master_thread(2, &process_pv_base::master_2_write);
}

void process_pv::master_3_thread()
{
    general_master_thread(3, &process_pv_base::master_3_write);
}

void process_pv::master_4_thread()
{
    general_master_thread(4, &process_pv_base::master_4_write);
}

void process_pv::master_5_thread()
{
    general_master_thread(5, &process_pv_base::master_5_write);
}

void process_pv::master_6_thread()
{
    general_master_thread(6, &process_pv_base::master_6_write);
}

void process_pv::master_7_thread()
{
    general_master_thread(7, &process_pv_base::master_7_write);
}

void process_pv::master_8_thread()
{
    general_master_thread(8, &process_pv_base::master_8_write);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

bool process_pv::general_slave_write(mb_address_type address,
                                     unsigned char* data,
                                     unsigned int size,
                                     unsigned int path,
                                     port_enum idx,
                                     tlm::tlm_fifo<datastruct *> & fifo,
                                     mb::mb_variable<int>& deltaVar,
                                     mb::mb_variable<int>& startVar,
                                     mb::mb_variable<int>& stopVar)
{
    datastruct* ds = new datastruct;
    ds->path = path;
    ds->address = address;
    ds->data = new unsigned char [size];
    memcpy(ds->data, data, size);
    ds->size = size;
    ds->currentToken = get_current_token();

    int throughput = size / getSystemCBaseModel()->get_port_width(idx);
    int receiveT = throughput + InputDelay;
    ds->receiveT = sc_time_stamp() + (receiveT * clock);

    bool putBlocked = !fifo.nb_can_put();
    fifo.put(ds);

    int *d = (int *) ds->data;
    cout << sc_simulation_time() << ":" << name() << " [" << path << "] received data = " << d[0] << endl;

    ds->startT = sc_time_stamp() + (receiveT * clock);

    if (putBlocked) {
        deltaVar = receiveT;
        startVar = (startVar + 1) % 8;
        stopVar = (stopVar + 1) % 8;
    }

    return true;
}

bool process_pv::slave_1_callback_write(mb_address_type address, unsigned char* data, unsigned size)
{
    return general_slave_write(address, data, size, 1,
                               slave_1_idx, slave_fifo[0],
                               slave_1_InputDelta, slave_1_ID_start, slave_1_ID_stop);
}

bool process_pv::slave_2_callback_write(mb_address_type address, unsigned char* data, unsigned size)
{
    return general_slave_write(address, data, size, 2,
                               slave_2_idx, slave_fifo[1],
                               slave_2_InputDelta, slave_2_ID_start, slave_2_ID_stop);
}

bool process_pv::slave_3_callback_write(mb_address_type address, unsigned char* data, unsigned size)
{
    return general_slave_write(address, data, size, 3,
                               slave_3_idx, slave_fifo[2],
                               slave_3_InputDelta, slave_3_ID_start, slave_3_ID_stop);
}

bool process_pv::slave_4_callback_write(mb_address_type address, unsigned char* data, unsigned size)
{
    return general_slave_write(address, data, size, 4,
                               slave_4_idx, slave_fifo[3],
                               slave_4_InputDelta, slave_4_ID_start, slave_4_ID_stop);
}

bool process_pv::slave_5_callback_write(mb_address_type address, unsigned char* data, unsigned size)
{
    return general_slave_write(address, data, size, 5,
                               slave_5_idx, slave_fifo[4],
                               slave_5_InputDelta, slave_5_ID_start, slave_5_ID_stop);
}

bool process_pv::slave_6_callback_write(mb_address_type address, unsigned char* data, unsigned size)
{
    return general_slave_write(address, data, size, 6,
                               slave_6_idx, slave_fifo[5],
                               slave_6_InputDelta, slave_6_ID_start, slave_6_ID_stop);
}

bool process_pv::slave_7_callback_write(mb_address_type address, unsigned char* data, unsigned size)
{
    return general_slave_write(address, data, size, 7,
                               slave_7_idx, slave_fifo[6],
                               slave_7_InputDelta, slave_7_ID_start, slave_7_ID_stop);
}

bool process_pv::slave_8_callback_write(mb_address_type address, unsigned char* data, unsigned size)
{
    return general_slave_write(address, data, size, 8,
                               slave_8_idx, slave_fifo[7],
                               slave_8_InputDelta, slave_8_ID_start, slave_8_ID_stop);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

