
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file contains the PV class for switch.
//* This is a template file: You may modify this file to implement the 
//* behavior of your component. 
//* 
//* Model Builder version: 3.4.0
//* Generated on: Jun. 01, 2012 12:32:14 PM, (user: jon)
//*>



#include "switch_pv.h"
#include <iostream>

using namespace sc_core;
using namespace sc_dt;
using namespace std;

//constructor
switch_pv::switch_pv(sc_module_name module_name) 
  : switch_pv_base(module_name) {

  SC_THREAD(thread);

  fifo_a.nb_bound(InputFifoDepthA);
  fifo_b.nb_bound(InputFifoDepthB);
}    

// Read callback for a port.
// Returns true when successful.
bool switch_pv::a_callback_read(mb_address_type address, unsigned char* data, unsigned size) {
  cout << sc_time_stamp() << ":" << name() << ".a_callback_read(). Error: Read not supported." << endl;
  return true;
}


// Read callback for b port.
// Returns true when successful.
bool switch_pv::b_callback_read(mb_address_type address, unsigned char* data, unsigned size) {
  cout << sc_time_stamp() << ":" << name() << ".b_callback_read(). Error: Read not supported." << endl;
  return true;
}

// Write callback for a port.
// Returns true when successful.
bool switch_pv::a_callback_write(mb_address_type address, unsigned char* data, unsigned size) {

  // Calculate the cycles until the input transaction will be complete
  int throughput = size / getSystemCBaseModel()->get_port_width(a_idx);
  int receiveT = throughput + InputDA;
  return addToQueue(address, data, size, receiveT, fifo_b);
  
} 

// Write callback for b port.
// Returns true when successful.
bool switch_pv::b_callback_write(mb_address_type address, unsigned char* data, unsigned size) {

  // Calculate the cycles until the input transaction will be complete
  int throughput = size / getSystemCBaseModel()->get_port_width(b_idx);
  int receiveT = throughput + InputDB;
  return addToQueue(address, data, size, receiveT, fifo_b);
  
} 

unsigned switch_pv::a_callback_read_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  // This just forwards the request.  It may need to return local data if appropriate.
  y_read_dbg(address, data, size);
  return true;
} 

unsigned switch_pv::a_callback_write_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  // This just forwards the request.  It may need to modify local data if appropriate.
  y_write_dbg(address, data, size);
  return true;
} 

bool switch_pv::a_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmiData) {
  // This just forwards the request.  It may need to return a pointer to local data if appropriate.
  y_get_direct_memory_prt(address, dmiData);
  return true;
}

unsigned switch_pv::b_callback_read_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  // This just forwards the request.  It may need to return local data if appropriate.
  y_read_dbg(address, data, size);
  return true;
} 

unsigned switch_pv::b_callback_write_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  // This just forwards the request.  It may need to modify local data if appropriate.
  y_write_dbg(address, data, size);
  return true;
} 

bool switch_pv::b_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmiData) {
  // This just forwards the request.  It may need to return a pointer to local data if appropriate.
  y_get_direct_memory_prt(address, dmiData);
  return true;
}


bool switch_pv::a_callback_write(mb_address_type address, 
				 unsigned char* data, 
				 unsigned size,
				 int receiveT,
				 tlm::tlm_fifo<datastruct *> & fifo) {

  datastruct * ds = new datastruct;

  // Save the transaction information in a local datastructure
  ds->address = address;
  ds->data = new unsigned char [size];
  memcpy(ds->data, data, size);
  ds->size = size;
  ds->currentToken = get_current_token();
  ds->startT = sc_time_stamp() + (receiveT * clock);

  // Put the transaction datastruct into the queue to be processed
  fifo.put(ds);

  return true;
}


void switch_pv::thread() {
  datastruct *ds, *dsA, *dsB;
  int proc;
  sc_time startProcT;
  tlm::tlm_fifo<datastruct *> * fifo);
  
  for(;;) {
    // Get the next transaction to be passed.  Do not remove it from the queue
    dsA = fifoA.nb_peek();
    dsB = fifoB.nb_peek();

    // Handle blocking?
    while ( 1 ) {
      if (!fifoA.nb_peek(dsptr)) {
        if (!fifoB.nb_peek(dsptr)) {
          wait (P0.ok_to_put() | P1.ok_to_put());
        } else
          break;
      } else
        break ;
    }

    if (  dsB == NULL || 
        ((dsA != NULL) && (dsA->startT <= dsB->startT)) ) {
      ds = dsA;
      fifo = &fifoA;
    } else {
      ds = dsB;
      fifo = &fifoB;
    }

    // Calculate the time that we could start sending the transaction
    startProcT = ds->startT;

    // Calculate the time to wait until we can start processing.  This can not be less than 0
    proc = (startProcT/clock) - (sc_time_stamp()/clock);
    proc = (proc < -processFactor) ? -processFactor : proc;
    m_processd = processFactor + proc;

    // Timing policy: Sequential delay TP2.write -> TP1.write of m_processd cycles
    TP1 = (TP1 + 1) % 8; TP2 = (TP2 + 1) % 8;

    // Save the current token information for the upcoming transaction and clear it from the queue
    set_current_token(ds->currentToken);
    fifo->get();

    y_send(ds->data, ds->size);
    
    free(ds->data);
    free(ds);
  }
}
