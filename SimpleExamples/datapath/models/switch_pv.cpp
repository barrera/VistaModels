/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file contains the PV class for switch.
//* This is a template file: You may modify this file to implement the
//* behavior of your component.
//*
//* Model Builder version: 3.4.0
//* Generated on: Jun. 01, 2012 12:32:14 PM, (user: jon)
//*>



#include "switch_pv.h"
#include <iostream>

using namespace sc_core;
using namespace sc_dt;
using namespace std;

//constructor
switch_pv::switch_pv(sc_module_name module_name)
    : switch_pv_base(module_name)
{
    SC_THREAD(thread1);

    fifo_1a.nb_bound(InputFifoDepth);
    fifo_1b.nb_bound(InputFifoDepth);
}

// Write callback for slave_1a port.
// Returns true when successful.
bool switch_pv::slave_1a_callback_write(mb_address_type address, unsigned char* data, unsigned size)
{
    // Calculate the cycles until the input transaction will be complete
    int throughput = size / getSystemCBaseModel()->get_port_width(slave_1a_idx);
    int receiveT = throughput + InputDelay;
    return addToQueue(address, data, size, receiveT, fifo_1a);
}

// Write callback for slave_1b port.
// Returns true when successful.
bool switch_pv::slave_1b_callback_write(mb_address_type address, unsigned char* data, unsigned size)
{
    // Calculate the cycles until the input transaction will be complete
    int throughput = size / getSystemCBaseModel()->get_port_width(slave_1b_idx);
    int receiveT = throughput + InputDelay;
    return addToQueue(address, data, size, receiveT, fifo_1b);
}

bool switch_pv::addToQueue(mb_address_type address,
                           unsigned char* data,
                           unsigned int size,
                           int receiveT,
                           tlm::tlm_fifo<datastruct *> & fifo)
{
    // Save the transaction information in a local datastructure
    datastruct* ds = new datastruct;
    ds->address = address;
    ds->data = new unsigned char [size];
    memcpy(ds->data, data, size);
    ds->size = size;
    ds->currentToken = get_current_token();

    InputDelta = receiveT;

    bool putBlocked = !fifo.nb_can_put();
    fifo.put(ds);

    ds->startT = sc_time_stamp() + (receiveT * clock);

    if (putBlocked) {
        // Timing policy: Sequential delay TP4.write -> TP3.write of InputDelta cycles
        TP3 = (TP3 + 1) % 8;
        TP4 = (TP4 + 1) % 8;
    }

    return true;
}

void switch_pv::thread1()
{
    datastruct *ds, *dsA, *dsB;
    int proc;
    sc_time startProcT;
    tlm::tlm_fifo<datastruct *> *fifo;

    for(;;) {

        while ( 1 ) {
            dsA = NULL;
            dsB = NULL;
            if (!fifo_1a.nb_peek(dsA)) {
                if (!fifo_1b.nb_peek(dsB)) {
                    wait (fifo_1a.ok_to_get() | fifo_1b.ok_to_get());
                } else {
                    break;
                }
            } else {
                fifo_1b.nb_peek(dsB);
                break;
            }
        }

        if (dsB == NULL || ((dsA != NULL) && (dsA->startT <= dsB->startT)) ) {
            ds = dsA;
            fifo = &fifo_1a;
        } else {
            ds = dsB;
            fifo = &fifo_1b;
        }

        // Calculate the time that we could start sending the transaction
        startProcT = ds->startT;

        // Calculate the time to wait until we can start processing.  This can not be less than 0
        proc = (startProcT/clock) - (sc_time_stamp()/clock);
        proc = (proc < -ProcessDelay) ? -ProcessDelay : proc;
        ProcessDelta = ProcessDelay + proc;

        // Timing policy: Sequential delay TP2.write -> TP1.write of ProcessDelta cycles
        TP1 = (TP1 + 1) % 8;
        TP2 = (TP2 + 1) % 8;

        // Save the current token information for the upcoming transaction and clear it from the queue
        set_current_token(ds->currentToken);
        fifo->get();

        master_1_write(ds->address, ds->data, ds->size);

        free(ds->data);
        free(ds);
    }
}
