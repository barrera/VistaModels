/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file contains the PV class for driver.
//* This is a template file: You may modify this file to implement the
//* behavior of your component.
//*
//* Model Builder version: 3.2.0RC
//* Generated on: Feb. 23, 2012 07:57:39 AM, (user: jon)
//*>


#include "driver_pv.h"

#include <iostream>
#include <fstream>
#include <sstream>
#include <string>

using namespace std;

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

driver_pv::driver_pv(sc_module_name module_name)
    : driver_pv_base(module_name)
{
    SC_THREAD(thread1);
    SC_THREAD(thread2);
    SC_THREAD(thread3);
    SC_THREAD(thread4);
    SC_THREAD(thread5);
    SC_THREAD(thread6);
    SC_THREAD(thread7);
    SC_THREAD(thread8);
}

driver_pv::~driver_pv()
{
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void driver_pv::general_thread(string path,
                               bool (driver_pv_base::*writeMethod)(mb_address_type, unsigned int *, unsigned, unsigned))
{
    bool process = false;
    string line, cmd;
    ifstream myfile (DataFilePath);
    if (myfile.is_open()) {
        while ( myfile.good() ) {
            getline (myfile,line);
            if(line.length() < 4) continue;
            cmd = line.substr(0, 4);
            if(line.length() > 5) {
                line = line.substr(5);
            }

            istringstream ss(line);
            vector <string> record;

            if(!cmd.compare("path")) {
                if(!line.compare(path)) {
                    process = true;
                }
            }
            if(!cmd.compare("stop")) {
                process = false;
            }
            if(process) {
                if(!cmd.compare("wait")) {
                    string s;
                    if (!getline(ss, s, ',' )) break;
                    stringstream conv;
                    conv << s;
                    int cycles;
                    conv >> cycles;
                    wait(cycles * generic_clock);
                }
                if(!cmd.compare("send")) {
                    int value, size;
                    string s;
                    if (!getline(ss, s, ',' )) break;
                    stringstream conv1;
                    conv1 << s;
                    conv1 >> value;
                    if (!getline(ss, s, ',' )) break;
                    stringstream conv2;
                    conv2 << s;
                    conv2 >> size;

                    unsigned int *d = new unsigned int[size];
                    for(int i = 0; i < size; i++) {
                        d[i] = value;
                    }
                    string msg("[");
                    msg += path;
                    msg += "]";

                    general_write(0x0, d, size, msg.c_str(), writeMethod);

                    delete d;
                }
            }
        }
        myfile.close();
    } else {
        cout << "Unable to open file" << DataFilePath << endl;
    }
    cout << sc_simulation_time() << ":" << name() << " ended thread" << path << endl;
}

void driver_pv::thread1()
{
    general_thread("1", &driver_pv_base::master_1_write);
}

void driver_pv::thread2()
{
    general_thread("2", &driver_pv_base::master_2_write);
}

void driver_pv::thread3()
{
    general_thread("3", &driver_pv_base::master_3_write);
}

void driver_pv::thread4()
{
    general_thread("4", &driver_pv_base::master_4_write);
}

void driver_pv::thread5()
{
    general_thread("5", &driver_pv_base::master_5_write);
}

void driver_pv::thread6()
{
    general_thread("6", &driver_pv_base::master_6_write);
}

void driver_pv::thread7()
{
    general_thread("7", &driver_pv_base::master_7_write);
}

void driver_pv::thread8()
{
    general_thread("8", &driver_pv_base::master_8_write);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

bool driver_pv::general_write(mb_address_type address, unsigned int *data, unsigned size, const char* extra,
                              bool (driver_pv_base::*writeMethod)(mb_address_type, unsigned int *, unsigned, unsigned))
{
    mb::mb_token_ptr tokenptr = new mb::mb_token;
    tokenptr->setField("CreateTime", sc_simulation_time());
    set_current_token(tokenptr);

    cout << sc_simulation_time() << ":" << name() << " " << extra << " sending data = " << data[0] << endl;
    return (this->*writeMethod)(address, data, size, 0);
}

