
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file contains the PV class for driver.
//* This is a template file: You may modify this file to implement the
//* behavior of your component.
//*
//* Model Builder version: 3.2.0RC
//* Generated on: Feb. 23, 2012 07:57:39 AM, (user: jon)
//*>


#include "driver_pv.h"

//constructor
driver_pv::driver_pv(sc_module_name module_name)
  : driver_pv_base(module_name)
{
  SC_THREAD(thread);
}

driver_pv::~driver_pv() {
}

void driver_pv::thread() {
  if (strcmp(DriverFunction, "off") == 0);
    //do nothing
  else if (strcmp(DriverFunction, "simple") == 0)
    simple();
  else if (strcmp(DriverFunction, "random") == 0)
    random();
  else {
    std::cout << this->name() << " thread(): Parameter DriverFunction = " << DriverFunction;
    std::cout << ". This value is not defined, it will be ignored." << endl;
  }
  cout << sc_simulation_time() << ":" << name() << " ended thread" << endl;
}

bool driver_pv::master_1_write(mb_address_type address, unsigned int *data, unsigned size) {
  mb::mb_token_ptr tokenptr = new mb::mb_token;
  tokenptr->setField("CreateTime", sc_simulation_time());
  set_current_token(tokenptr);

  cout << sc_simulation_time() << ":" << name() << " sending data = " << data[0] << endl;

  return driver_pv_base::master_1_write(address, data, size);
}

void driver_pv::simple() {
  unsigned int d[10] = {101, 102, 103, 104, 105, 106, 107, 108, 109, 110};
  wait(10*generic_clock);

  master_1_write(0x0, &d[0], 1);
  wait(4*generic_clock);

  master_1_write(0x0, &d[1], 2);
  wait(10*generic_clock);

  master_1_write(0x0, &d[2], 4);
  wait(10*generic_clock);

  master_1_write(0x0, &d[3], 2);
  master_1_write(0x0, &d[4], 6);
  master_1_write(0x0, &d[5], 2);

  wait(4*generic_clock);
  master_1_write(0x0, &d[6], 1);
}

void driver_pv::random() {
  mb_distribution *sizedist = mb_CreateDistribution(SizeDist);
  mb_distribution *addrdist = mb_CreateDistribution(AddrDist);
  mb_distribution *waitdist = mb_CreateDistribution(WaitDist);
  unsigned int d[MaxPacketSize];
  unsigned int s, a;

  srand(5647);

  for (unsigned i = 0; i < NumberPackets; i++) {
    a = addrdist->getNextInt();
    s = sizedist->getNextInt();
    s = s % MaxPacketSize;

    d[0] = i+1;

    master_1_write(a, d, s);

    wait(waitdist->getNextInt() * clock);
  }
}
