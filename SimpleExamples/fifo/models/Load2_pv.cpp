
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file contains the PV class for Load2.
//* This is a template file: You may modify this file to implement the 
//* behavior of your component. 
//* 
//* Model Builder version: 3.0.1.beta1
//* Generated on: Mar. 26, 2010 09:17:47 AM, (user: jon)
//* Automatically merged on: Jul. 02, 2010 02:43:32 PM, (user: jon)
//* Automatically merged on: Feb. 03, 2011 04:11:51 PM, (user: jon)
//* Automatically merged on: Jan. 24, 2012 07:43:18 AM, (user: jon)
//*>


#include "Load2_pv.h"
#include <iostream>

//constructor
Load2_pv::Load2_pv(sc_module_name module_name) 
  : Load2_pv_base(module_name) {
   SC_THREAD(thread);
   SC_THREAD(threadP0);
   SC_THREAD(threadP1);
} 


// This thread can be uses to generate outgoing transactions
void Load2_pv::thread() {
  lastSentTime = sc_time_stamp();
  sc_time dperiod = sc_time(DPeriod * clock);
  datastruct *dsptr;

  wait(SC_ZERO_TIME);
for (int j=0; j<3; j++) {
  for(Count = 1; Count <= COUNT; Count++) {
    dsptr = new datastruct();
    dsptr->id = Count;
    dsptr->d = Count;

    while ( 1 ) {
      if (!P0.nb_put(dsptr)) {
        if (!P1.nb_put(dsptr)) {
          wait (P0.ok_to_put() | P1.ok_to_put());
        } else
          break;
      } else
        break ;
    }

    dtime = dperiod * ((COUNT*j) + ((j+1) * Count));
    if (dtime > sc_time_stamp())
      wait(dtime - sc_time_stamp()) ;
  }
      wait(10, SC_US) ;
}
}

void Load2_pv::threadP0() {
  for(;;) {
    data0 = P0.peek();
    P0Busy = true;

    cout << sc_time_stamp() << ":" << name() << " threadP0 sending data = " << data0->id << endl;
    token0 = get_current_token();
sc_time start = sc_time_stamp();
    m0_write(0x0, (unsigned char *) data0, sizeof(datastruct));
    P0Busy = false;
cout << "Load2 m0_write time : " << sc_time_stamp() - start << ", time = " << sc_time_stamp() << endl;
    P0.get();
    free(data0);
  }
}   

void Load2_pv::threadP1() {
  for(;;) {
    data1 = P1.peek();
    P1Busy = true;

    cout << sc_time_stamp() << ":" << name() << " threadP1 sending data = " << data1->id << endl;
    token1 = get_current_token();
sc_time start = sc_time_stamp();
    m1_write(0x0, (unsigned char *) data1, sizeof(datastruct));
    P1Busy = false;
cout << "Load2 m1_write time : " << sc_time_stamp() - start << ", time = " << sc_time_stamp() << endl;
    P1.get();
    free(data1);
  }
}   

